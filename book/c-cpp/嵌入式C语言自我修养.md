# 嵌入式 C 语言自我修养——从芯片、编译器到操作系统

## 第二章 计算机体系结构和 CPU 工作原理
### 缓存
- **有速度瓶颈的地方就有缓存**，这种思想在计算机中随处可见；
- `Cache` 在物理实现上为 `SRAM`，其运行速度介于 `CPU` 和内存 `DRAM` 之间，是在 `CPU` 和内存之间插入的一组高速缓冲存储器，**用来解决两者速度不匹配带来的瓶颈问题**；
- `Cache` 工作原理，利用空间局部性和时间局部性原理，通过自有的存储空间，缓存一部分内存中的指令和数据，减少 `CPU` 访问内存的次数，从而提高系统的整体性能；多级 `Cache`：
  - 一级 `Cache` 位于 `CPU` 内部，受到占用面积和发热量等限制；
  - 外加多级 `Cache`，可以提高缓存命中率；
- 处理器没有 `Cache`：
  - `Cache` 增加了芯片的面积和发热量；
  - 这里处理器本来的工作频率不高（从几十兆到几百兆不等），和 `RAM` 之间不存在带宽问题，而且有的甚至无需外接 `RAM`；
  - **使用 `Cache` 无法保证实时性**，当缓存未命中时，`CPU` 从 `RAM` 中读取数据的时间是不确定的，这时嵌入式实时控制场景无法接受的；

### 流水线
- 流水线操作和对应电路：
  - 取指令      翻译指令    执行指令
  - 取值单元    译码单元    执行单元
- 提升流水线性能（减少木桶短板效应操作的耗时）：
  - 提高 `CPU` 频率：**`CPU` 内部的数字电路是靠时钟驱动工作的**，既然每条指令的执行时钟周期数不变，则可以通过缩短一个时钟周期的时间来提升效率，以减少每条指令所耗费时间。上限受到组合逻辑处理 + 寄存器操作耗时限制；
  - 增加流水线深度：将耗时的操作拆分成多个操作的组合；
- 5 级以上的流水线称为超流水线结构；
- 流水线深度越深，由跳转指令、分支结构导致的浪费和损失会越严重，损失是指流水线的冲刷和停顿；
- 流水线冒险：
  指令之前存在互斥关系或各种依赖关系，导致事先位于流水线中的指令未对应到最新的运算、逻辑处理结果，即预取指令失败；
  - 结构冒险：所需的硬件正在为前面的指令工作；
  - 数据冒险：指令前后有数据依赖关系，当前指令需要前面指令的运算数据才能工作；现在的经典 `CPU` 流水线一般分为 5 级：**取指、译码、执行、访问内存、写回，即指令执行结束后还要把运算结果写回寄存器**，然后下一条指令才可以到这个寄存器取数据。一种解决流水线数据冒险的方法：添加空指令，让流水线暂时停顿（`stall`），产生空泡（`bubble`）；
  - 控制冒险：需根据之前指令的执行结果决定下一步的行为；
- **分支预测**：
  现在的 `CPU` 流水线在取指和译码时，都要对跳转指令进行分析，预测可能执行的分支和路径，防止预取错误的分支路径指令给流水线带来停顿；
  - 静态预测：程序编译时，通过编译器进行分支预测。对循环程序最有效，而对于跳转指令一般都是默认不跳转，按照顺序执行，**因此在编写有跳转分支的程序时，要记得把大概率执行的代码分支放在前面，这样可以明显提高代码的执行效率**；
  - 动态预测：在 `CPU` 内部，除了 `Cache` 就数分支预测器的电路版图最大；
  
  分支预测技术是提高 `CPU` 性能的一项关键技术，其本质是去除指令间的相关性，让程序更高效运行。影响 `CPU` 性能的几项指标：流水线深度、主频多高、`Cache` 多大、分支预测器性能（分支判断的速度和预测准确率）；
- **乱序执行**：
  - 对于数据冒险，可以通过在指令序列之间添加空指令，让流水线暂时停顿来避免流水线中预期的指令被冲刷掉。除此以外，还可以通过乱序执行（`out of order`）来避免流水线冲突；
  - 造成流水线冲突的根源在于指令之间存在相关性，前后指令之间要么产生数据冒险，要么产生结构冒险，可以通过重排指令的执行顺序，而不是被动地填充空指令（造成流水线频繁停顿）来去掉这种依赖；
- `SIMD` 和 `NEON`
  - `SIMD`：单指令多数据，几个执行部件同时访问内存，一次性读取所有地操作数，实现数据并行访问（图像、音视频数据处理、数据密集型计算）；
  - `NEON`：适用于 `Cortex-A` 和 `Cortex-R52` 系列处理器地一种 128 位地 `SIMD` 扩展指令集；
- 单发射和多发射
  - 单发射：一个时钟周期只能取一个指令、执行一个指令；
  - 多发射：一个时钟周期可以执行多条指令；`CPU` 中有多个执行单元：`ALU`、乘法器、浮点运算单元（`FPU`）等，`CPU` 在一个时钟周期内分发（`dispatch`）多条指令到不同的执行单元运行；
  - `EPIC`：`Explicitly Parallel Instruction Computing`；

## ARM 体系结构与汇编语言
### ARM 汇编指令
`ARM` 指令集属于 `RISC` 指令集，**`RISC` 处理器采用典型的加载/存储体系结构**，`CPU` 无法对内存里的数据直接操作，只能通过 `load/store` 指令来实现。需要对内存中的数据进行操作时，要首先将这个数据从内存加载到寄存器，然后在寄存器中对数据进行处理，最后将结构重新存储到内存中；

1. 跳转指令
   - `B label`：
     - 跳转到标号 `label` 处；
     - `B` 跳转指令的**跳转范围为 `[0, 32MB]`**；
     - 可往前跳，也可往后跳；
     - 无条件跳转指令主要用在循环、分支结构的汇编程序中；
   - `BL label`：
     - 表示带链接的跳转。在跳转之前，`BL` 指令会先将当前指令的下一条指令地址（即返回地址）保存到 `LR` 寄存器中，然后跳转到 `label` 处执行；
     - 一般用在函数调用的场合，子函数执行结束后，`LR` 寄存器中的值（地址）被赋值给 `PC` 寄存器，处理器就可以返回到原来的主函数中继续运行了；
   - `BX Rm`：
     - 表示带状态切换的跳转、`Rm` 寄存器中保存的是跳转地址；
     - 要跳转的目标可能是 `ARM` 指令，也可能是 `Thumb` 指令，处理器根据 `Rm[0]` 位决定切换到 `ARM` 状态还是 `Thumb` 状态；`0-ARM, 1-Thumb`;
   - `BLX`：是 `BL` 指令和 `BX` 指令的综合，表示带链接和状态切换的跳转；

### ARM 寻址方式
`ARM` 属于 `RISC` 体系架构，一个 `ARM` 汇编程序中的大部分汇编指令都与数据传输有关：内存->寄存器、内存->内存、寄存器->寄存器。

1. 寄存器寻址：寄存器之间；
2. 立即数寻址：`ARM` 指令中的操作数为一个常数，立即数以 `#` 为前缀；
3. 寄存器偏移寻址：寄存器的左移、右移；
4. 寄存器间接寻址：主要用来在内存和寄存器之间传输数据。寄存器中保存的数据在内存中的存储地址，通过这个地址就可以在寄存器和内存之间传输数据。**C 语言中的指针操作，在汇编层次其实就是使用寄存器间接寻址来实现的**；
5. 基址寻址：属于寄存器寻址，两者的不同之处在于：基址寻址将寄存器中地址与一个偏移量相加生成一个新地址，然后基于这个新地址去访问内存。一般用在查表、数组访问、函数的栈帧管理等场合。根据偏移的正负也可以向前索引寻址和向后索引寻址；
6. 多寄存器寻址：`STM/LDM` 指令，一次可以传输多个寄存器的值，可和下述组合使用：
   - `IA`： Increase after,
   - `IB`： Increase before,
   - `DA`： decrease after,
   - `DB`： decrease before,
   - `FD`： 满递减堆栈，full descend,
   - `ED`： 空递减堆栈，empty descend,
   - `FA`： 满递增堆栈，full ascend,
   - `EA`： 空递增堆栈，empty ascend,
  
    满：`SP` 指针指向当前栈顶元素、空：`SP` 指针指向当前栈顶元素的下一个元素；
    `ARM` 中没有专门的入栈和出栈指令。其中的 `PUSH` 和 `POP` 指令其实是 `STMFD` 和 `LDMFD` 组合指令的助记符；
7. 相对寻址：也属于基址寻址，是基址寻址的一种特殊情况。
   - 它以 `PC` 指针作为基地址进行寻址，以指令中的地址差作为偏移；
   - `ARM` 中的 `B, BL, ADR` 指令其实都是采用相对寻址的；
   - 很多与位置无关的代码，如动态链接库，其在汇编代码层次的实现其实是采用相对寻址的。**程序中使用相对寻址访问的好处是不需要重定位**，将代码加载内存中的任何地址都可以直接运行。

## 栈内存
1. 局部变量不一定全部都保存在栈中，当编译器优化时可能使用寄存器来表示某些局部变量，此时该变量并不占用栈空间。可以使用 `volatile` 来阻止编译器的优化，此时该变量一般会占用栈空间；
2. 内存使用情况和 `SP, FP`：
   ```bash
            PC                             <-----------
            LR                                        |
    main    SP                                        |
    stack   FP                                        |
    frames  main argument: argc                       |
            main argument: argv                       |
            main local variable: i = 10                |
            main local variable: j = 5                 |
            the 5th parameter for func1: 2 <-------   |
   FP-----> PC                                    |   |
            LR                                    |   |
    func1   SP  -----------------------------------   |
    stack   FP  ---------------------------------------
    frames  func1 param: p1
            func1 param: p2
            func1 param: p3
   SP-----> func1 param: p4
   ```
   没有独立的专用寄存器 `FP`（栈基址）编号，而是由 `R11` 兼任（`SP, R13`）。编译器在需要栈指针就把 `R11` 当作 `FP` 使用，用于指向当前栈帧的基地址，方便局部变量与参数定位；

## C 的面向对象
1. C 文件本身（编译单元 + `static`）实现封装 + `struct`（结构体）实现对外的数据 + 方法；
